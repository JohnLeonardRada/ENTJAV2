½çš„å€¼æœ‰ï¼š "

#. Tag: para
#, no-c-format
msgid "<literal>auto</literal> (the default): this choice delegates to the release mode returned by the <literal>org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</literal> method. For JTATransactionFactory, this returns ConnectionReleaseMode.AFTER_STATEMENT; for JDBCTransactionFactory, this returns ConnectionReleaseMode.AFTER_TRANSACTION. Do not change this default behavior as failures due to the value of this setting tend to indicate bugs and/or invalid assumptions in user code."
msgstr "<literal>auto</literal>ï¼ˆé»˜è®¤ï¼‰ï¼šè¿™ä¸€é€‰æ‹©æŠŠé‡Šæ”¾æ¨¡å¼å§”æ´¾ç»™ <literal>org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</literal> æ–¹æ³•ã€‚å¯¹ JTATransactionFactory æ¥è¯´ï¼Œå®ƒä¼šè¿”å› ConnectionReleaseMode.AFTER_STATEMENTï¼›å¯¹ã€€JDBCTransactionFactoryã€€æ¥è¯´ï¼Œåˆ™æ˜¯ConnectionReleaseMode.AFTER_TRANSACTIONã€‚å¾ˆå°‘éœ€è¦ä¿®æ”¹è¿™ä¸€é»˜è®¤è¡Œä¸ºï¼Œå› ä¸ºå‡è‹¥è®¾ç½®ä¸å½“ï¼Œå°±ä¼šå¸¦æ¥ bugï¼Œæˆ–è€…ç»™ç”¨æˆ·ä»£ç å¸¦æ¥è¯¯å¯¼ã€‚"

#. Tag: para
#, no-c-format
msgid "<literal>on_close</literal>: uses ConnectionReleaseMode.ON_CLOSE. This setting is left for backwards compatibility, but its use is discouraged."
msgstr "<literal>on_close</literal>ï¼šä½¿ç”¨ ConnectionReleaseMode.ON_CLOSEã€‚è¿™ç§æ–¹å¼æ˜¯ä¸ºäº†å‘ä¸‹å…¼å®¹çš„,ä½†æ˜¯å·²ç»å®Œå…¨ä¸è¢«é¼“åŠ±ä½¿ç”¨äº†ã€‚"

#. Tag: para
#, no-c-format
msgid "<literal>after_transaction</literal>: uses ConnectionReleaseMode.AFTER_TRANSACTION. This setting should not be used in JTA environments. Also note that with ConnectionReleaseMode.AFTER_TRANSACTION, if a session is considered to be in auto-commit mode, connections will be released as if the release mode were AFTER_STATEMENT."
msgstr "<literal>after_transaction</literal>ï¼šä½¿ç”¨ ConnectionReleaseMode.AFTER_TRANSACTIONã€‚è¿™ä¸€è®¾ç½®ä¸åº”è¯¥åœ¨ JTA ç¯å¢ƒä¸‹ä½¿ç”¨ã€‚ä¹Ÿè¦æ³¨æ„ï¼Œä½¿ç”¨ ConnectionReleaseMode.AFTER_TRANSACTION çš„æ—¶å€™ï¼Œå‡è‹¥session å¤„äº auto-commit çŠ¶æ€ï¼Œè¿æ¥ä¼šåƒ AFTER_STATEMENT é‚£æ ·è¢«é‡Šæ”¾ã€‚"

#. Tag: para
#, no-c-format
msgid "<literal>after_statement</literal>: uses ConnectionReleaseMode.AFTER_STATEMENT. Additionally, the configured <literal>ConnectionProvider</literal> is consulted to see if it supports this setting (<literal>supportsAggressiveRelease()</literal>). If not, the release mode is reset to ConnectionReleaseMode.AFTER_TRANSACTION. This setting is only safe in environments where we can either re-acquire the same underlying JDBC connection each time you make a call into <literal>ConnectionProvider.getConnection()</literal> or in auto-commit environments where it does not matter if we re-establish the same connection."
msgstr "<literal>after_statement</literal>ï¼šä½¿ç”¨ ConnectionReleaseMode.AFTER_STATEMENTã€‚é™¤æ­¤ä¹‹å¤–ï¼Œä¼šæŸ¥è¯¢é…ç½®çš„ <literal>ConnectionProvider</literal>ï¼Œæ˜¯å¦å®ƒæ”¯æŒè¿™ä¸€è®¾ç½®ï¼ˆ<literal>supportsAggressiveRelease()</literal>ï¼‰ã€‚å‡è‹¥ä¸æ”¯æŒï¼Œé‡Šæ”¾æ¨¡å¼ä¼šè¢«è®¾ç½®ä¸º  ConnectionReleaseMode.AFTER_TRANSACTIONã€‚åªæœ‰åœ¨ä½ æ¯æ¬¡è°ƒç”¨  <literal>ConnectionProvider.getConnection()</literal> è·å–åº•å±‚ JDBC è¿æ¥çš„æ—¶å€™ï¼Œéƒ½å¯ä»¥ç¡®ä¿¡è·å¾—åŒä¸€ä¸ªè¿æ¥çš„æ—¶å€™ï¼Œè¿™ä¸€è®¾ç½®æ‰æ˜¯å®‰å…¨çš„ï¼›æˆ–è€…åœ¨ auto-commit ç¯å¢ƒä¸­ï¼Œä½ å¯ä»¥ä¸ç®¡æ˜¯å¦æ¯æ¬¡éƒ½è·å¾—åŒä¸€ä¸ªè¿æ¥çš„æ—¶å€™ï¼Œè¿™æ‰æ˜¯å®‰å…¨çš„ã€‚"

#~ msgid "foo==bar"
#~ msgstr "foo==bar"
#~ msgid ""
#~ "<![CDATA[// Non-managed environment idiom\n"
#~ "Session sess = factory.openSession();\n"
#~ "Transaction tx = null;\n"
#~ "try {\n"
#~ "    tx = sess.beginTransaction();\n"
#~ "\n"
#~ "    // do some work\n"
#~ "    ...\n"
#~ "\n"
#~ "    tx.commit();\n"
#~ "}\n"
#~ "catch (RuntimeException e) {\n"
#~ "    if (tx != null) tx.rollback();\n"
#~ "    throw e; // or display error message\n"
#~ "}\n"
#~ "finally {\n"
#~ "    sess.close();\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[// Non-managed environment idiom\n"
#~ "Session sess = factory.openSession();\n"
#~ "Transaction tx = null;\n"
#~ "try {\n"
#~ "    tx = sess.beginTransaction();\n"
#~ "\n"
#~ "    // do some work\n"
#~ "    ...\n"
#~ "\n"
#~ "    tx.commit();\n"
#~ "}\n"
#~ "catch (RuntimeException e) {\n"
#~ "    if (tx != null) tx.rollback();\n"
#~ "    throw e; // or display error message\n"
#~ "}\n"
#~ "finally {\n"
#~ "    sess.close();\n"
#~ "}]]>"
#~ msgid ""
#~ "<![CDATA[// Non-managed environment idiom with getCurrentSession()\n"
#~ "try {\n"
#~ "    factory.getCurrentSession().beginTransaction();\n"
#~ "\n"
#~ "    // do some work\n"
#~ "    ...\n"
#~ "\n"
#~ "    factory.getCurrentSession().getTransaction().commit();\n"
#~ "}\n"
#~ "catch (RuntimeException e) {\n"
#~ "    factory.getCurrentSession().getTransaction().rollback();\n"
#~ "    throw e; // or display error message\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[// Non-managed environment idiom with getCurrentSession()\n"
#~ "try {\n"
#~ "    factory.getCurrentSession().beginTransaction();\n"
#~ "\n"
#~ "    // do some work\n"
#~ "    ...\n"
#~ "\n"
#~ "    factory.getCurrentSession().getTransaction().commit();\n"
#~ "}\n"
#~ "catch (RuntimeException e) {\n"
#~ "    factory.getCurrentSession().getTransaction().rollback();\n"
#~ "    throw e; // or display error message\n"
#~ "}]]>"
#~ msgid ""
#~ "<![CDATA[// BMT idiom\n"
#~ "Session sess = factory.openSession();\n"
#~ "Transaction tx = null;\n"
#~ "try {\n"
#~ "    tx = sess.beginTransaction();\n"
#~ "\n"
#~ "    // do some work\n"
#~ "    ...\n"
#~ "\n"
#~ "    tx.commit();\n"
#~ "}\n"
#~ "catch (RuntimeException e) {\n"
#~ "    if (tx != null) tx.rollback();\n"
#~ "    throw e; // or display error message\n"
#~ "}\n"
#~ "finally {\n"
#~ "    sess.close();\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[// BMT idiom\n"
#~ "Session sess = factory.openSession();\n"
#~ "Transaction tx = null;\n"
#~ "try {\n"
#~ "    tx = sess.beginTransaction();\n"
#~ "\n"
#~ "    // do some work\n"
#~ "    ...\n"
#~ "\n"
#~ "    tx.commit();\n"
#~ "}\n"
#~ "catch (RuntimeException e) {\n"
#~ "    if (tx != null) tx.rollback();\n"
#~ "    throw e; // or display error message\n"
#~ "}\n"
#~ "finally {\n"
#~ "    sess.close();\n"
#~ "}]]>"
#~ msgid ""
#~ "<![CDATA[// BMT idiom with getCurrentSession()\n"
#~ "try {\n"
#~ "    UserTransaction tx = (UserTransaction)new InitialContext()\n"
#~ "                            .lookup(\"java:comp/UserTransaction\");\n"
#~ "\n"
#~ "    tx.begin();\n"
#~ "\n"
#~ "    // Do some work on Session bound to transaction\n"
#~ "    factory.getCurrentSession().load(...);\n"
#~ "    factory.getCurrentSession().persist(...);\n"
#~ "\n"
#~ "    tx.commit();\n"
#~ "}\n"
#~ "catch (RuntimeException e) {\n"
#~ "    tx.rollback();\n"
#~ "    throw e; // or display error message\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[// BMT idiom with getCurrentSession()\n"
#~ "try {\n"
#~ "    UserTransaction tx = (UserTransaction)new InitialContext()\n"
#~ "                            .lookup(\"java:comp/UserTransaction\");\n"
#~ "\n"
#~ "    tx.begin();\n"
#~ "\n"
#~ "    // Do some work on Session bound to transaction\n"
#~ "    factory.getCurrentSession().load(...);\n"
#~ "    factory.getCurrentSession().persist(...);\n"
#~ "\n"
#~ "    tx.commit();\n"
#~ "}\n"
#~ "catch (RuntimeException e) {\n"
#~ "    tx.rollback();\n"
#~ "    throw e; // or display error message\n"
#~ "}]]>"
#~ msgid ""
#~ "<![CDATA[// CMT idiom\n"
#~ " Session sess = factory.getCurrentSession();\n"
#~ "\n"
#~ " // do some work\n"
#~ " ...\n"
#~ "]]>"
#~ msgstr ""
#~ "<![CDATA[// CMT idiom\n"
#~ " Session sess = factory.getCurrentSession();\n"
#~ "\n"
#~ " // do some work\n"
#~ " ...\n"
#~ "]]>"
#~ msgid ""
#~ "<![CDATA[\n"
#~ "Session sess = factory.openSession();\n"
#~ "try {\n"
#~ "    //set transaction timeout to 3 seconds\n"
#~ "    sess.getTransaction().setTimeout(3);\n"
#~ "    sess.getTransaction().begin();\n"
#~ "\n"
#~ "    // do some work\n"
#~ "    ...\n"
#~ "\n"
#~ "    sess.getTransaction().commit()\n"
#~ "}\n"
#~ "catch (RuntimeException e) {\n"
#~ "    sess.getTransaction().rollback();\n"
#~ "    throw e; // or display error message\n"
#~ "}\n"
#~ "finally {\n"
#~ "    sess.close();\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[\n"
#~ "Session sess = factory.openSession();\n"
#~ "try {\n"
#~ "    //set transaction timeout to 3 seconds\n"
#~ "    sess.getTransaction().setTimeout(3);\n"
#~ "    sess.getTransaction().begin();\n"
#~ "\n"
#~ "    // do some work\n"
#~ "    ...\n"
#~ "\n"
#~ "    sess.getTransaction().commit()\n"
#~ "}\n"
#~ "catch (RuntimeException e) {\n"
#~ "    sess.getTransaction().rollback();\n"
#~ "    throw e; // or display error message\n"
#~ "}\n"
#~ "finally {\n"
#~ "    sess.close();\n"
#~ "}]]>"
#~ msgid ""
#~ "<![CDATA[// foo is an instance loaded by a previous Session\n"
#~ "session = factory.openSession();\n"
#~ "Transaction t = session.beginTransaction();\n"
#~ "\n"
#~ "int oldVersion = foo.getVersion();\n"
#~ "session.load( foo, foo.getKey() ); // load the current state\n"
#~ "if ( oldVersion != foo.getVersion() ) throw new StaleObjectStateException"
#~ "();\n"
#~ "foo.setProperty(\"bar\");\n"
#~ "\n"
#~ "t.commit();\n"
#~ "session.close();]]>"
#~ msgstr ""
#~ "<![CDATA[// foo is an instance loaded by a previous Session\n"
#~ "session = factory.openSession();\n"
#~ "Transaction t = session.beginTransaction();\n"
#~ "\n"
#~ "int oldVersion = foo.getVersion();\n"
#~ "session.load( foo, foo.getKey() ); // load the current state\n"
#~ "if ( oldVersion != foo.getVersion() ) throw new StaleObjectStateException"
#~ "();\n"
#~ "foo.setProperty(\"bar\");\n"
#~ "\n"
#~ "t.commit();\n"
#~ "session.close();]]>"
#~ msgid ""
#~ "<![CDATA[// foo is an instance loaded earlier by the old session\n"
#~ "Transaction t = session.beginTransaction(); // Obtain a new JDBC "
#~ "connection, start transaction\n"
#~ "\n"
#~ "foo.setProperty(\"bar\");\n"
#~ "\n"
#~ "session.flush();    // Only for last transaction in conversation\n"
#~ "t.commit();         // Also return JDBC connection\n"
#~ "session.close();    // Only for last transaction in conversation]]>"
#~ msgstr ""
#~ "<![CDATA[// foo is an instance loaded earlier by the old session\n"
#~ "Transaction t = session.beginTransaction(); // Obtain a new JDBC "
#~ "connection, start transaction\n"
#~ "\n"
#~ "foo.setProperty(\"bar\");\n"
#~ "\n"
#~ "session.flush();    // Only for last transaction in conversation\n"
#~ "t.commit();         // Also return JDBC connection\n"
#~ "session.close();    // Only for last transaction in conversation]]>"
#~ msgid ""
#~ "<![CDATA[// foo is an instance loaded by a previous Session\n"
#~ "foo.setProperty(\"bar\");\n"
#~ "session = factory.openSession();\n"
#~ "Transaction t = session.beginTransaction();\n"
#~ "session.saveOrUpdate(foo); // Use merge() if \"foo\" might have been "
#~ "loaded already\n"
#~ "t.commit();\n"
#~ "session.close();]]>"
#~ msgstr ""
#~ "<![CDATA[// foo is an instance loaded by a previous Session\n"
#~ "foo.setProperty(\"bar\");\n"
#~ "session = factory.openSession();\n"
#~ "Transaction t = session.beginTransaction();\n"
#~ "session.saveOrUpdate(foo); // Use merge() if \"foo\" might have been "
#~ "loaded already\n"
#~ "t.commit();\n"
#~ "session.close();]]>"

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  # translation of session_api.po to
# Xi Huang <xhuang@redhat.com>, 2006.
# Xi HUANG <xhuang@redhat.com>, 2007, 2009.
# translation of Collection_Mapping.po to
msgid ""
msgstr ""
"Project-Id-Version: session_api\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-07-21 05:43+0000\n"
"PO-Revision-Date: 2010-03-16 09:58+1000\n"
"Last-Translator: Xi HUANG <xhuang@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#: session_api.xml:31
#, no-c-format
msgid "Working with objects"
msgstr "ä¸å¯¹è±¡å…±äº‹"

#. Tag: para
#: session_api.xml:33
#, no-c-format
msgid ""
"Hibernate is a full object/relational mapping solution that not only shields "
"the developer from the details of the underlying database management system, "
"but also offers <emphasis>state management</emphasis> of objects. This is, "
"contrary to the management of SQL <literal>statements</literal> in common "
"JDBC/SQL persistence layers, a natural object-oriented view of persistence "
"in Java applications."
msgstr ""
"Hibernate æ˜¯å®Œæ•´çš„å¯¹è±¡/å…³ç³»æ˜ å°„è§£å†³æ–¹æ¡ˆï¼Œå®ƒæä¾›äº†å¯¹è±¡<emphasis>çŠ¶æ€ç®¡ç†"
"ï¼ˆstate managementï¼‰</emphasis>çš„åŠŸèƒ½ï¼Œä½¿å¼€å‘è€…ä¸å†éœ€è¦ç†ä¼šåº•å±‚æ•°æ®åº“ç³»ç»Ÿçš„ç»†"
"èŠ‚ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç›¸å¯¹äºå¸¸è§çš„ JDBC/SQL æŒä¹…å±‚æ–¹æ¡ˆä¸­éœ€è¦<literal>ç®¡ç† SQL è¯­å¥</"
"literal>ï¼ŒHibernate é‡‡ç”¨äº†æ›´è‡ªç„¶çš„é¢å‘å¯¹è±¡çš„è§†è§’æ¥æŒä¹…åŒ– Java åº”ç”¨ä¸­çš„æ•°æ®ã€‚ "

#. Tag: para
#: session_api.xml:40
#, no-c-format
msgid ""
"In other words, Hibernate application developers should always think about "
"the <emphasis>state</emphasis> of their objects, and not necessarily about "
"the execution of SQL statements. This part is taken care of by Hibernate and "
"is only relevant for the application developer when tuning the performance "
"of the system."
msgstr ""
"æ¢å¥è¯è¯´ï¼Œä½¿ç”¨ Hibernate çš„å¼€å‘è€…åº”è¯¥æ€»æ˜¯å…³æ³¨å¯¹è±¡çš„<emphasis>çŠ¶æ€ï¼ˆstateï¼‰</"
"emphasis>ï¼Œä¸å¿…è€ƒè™‘ SQL è¯­å¥çš„æ‰§è¡Œã€‚è¿™éƒ¨åˆ†ç»†èŠ‚å·²ç»ç”± Hibernate æŒç®¡å¦¥å½“ï¼Œåªæœ‰"
"å¼€å‘è€…åœ¨è¿›è¡Œç³»ç»Ÿæ€§èƒ½è°ƒä¼˜çš„æ—¶å€™æ‰éœ€è¦è¿›è¡Œäº†è§£ã€‚"

#. Tag: title
#: session_api.xml:47
#, no-c-format
msgid "Hibernate object states"
msgstr "Hibernate å¯¹è±¡çŠ¶æ€ï¼ˆobject statesï¼‰"

#. Tag: para
#: session_api.xml:49
#, no-c-format
msgid "Hibernate defines and supports the following object states:"
msgstr "Hibernate å®šä¹‰å¹¶æ”¯æŒä¸‹åˆ—å¯¹è±¡çŠ¶æ€ï¼ˆstateï¼‰ï¼š"

#. Tag: para
#: session_api.xml:53
#, no-c-format
msgid ""
"<emphasis>Transient</emphasis> - an object is transient if it has just been "
"instantiated using the <literal>new</literal> operator, and it is not "
"associated with a Hibernate <literal>Session</literal>. It has no persistent "
"representation in the database and no identifier value has been assigned. "
"Transient instances will be destroyed by the garbage collector if the "
"application does not hold a reference anymore. Use the Hibernate "
"<literal>Session</literal> to make an object persistent (and let Hibernate "
"take care of the SQL statements that need to be executed for this "
"transition)."
msgstr ""
"<emphasis>ç¬æ—¶ï¼ˆTransientï¼‰</emphasis> â€” ç”± <literal>new</literal> æ“ä½œç¬¦åˆ›"
"å»ºï¼Œä¸”å°šæœªä¸Hibernate <literal>Session</literal> å…³è”çš„å¯¹è±¡è¢«è®¤å®šä¸ºç¬æ—¶"
"ï¼ˆTransientï¼‰çš„ã€‚ç¬æ—¶ï¼ˆTransientï¼‰å¯¹è±¡ä¸ä¼šè¢«æŒä¹…åŒ–åˆ°æ•°æ®åº“ä¸­ï¼Œä¹Ÿä¸ä¼šè¢«èµ‹äºˆæŒ"
"ä¹…åŒ–æ ‡è¯†ï¼ˆidentifierï¼‰ã€‚ å¦‚æœç¬æ—¶ï¼ˆTransientï¼‰å¯¹è±¡åœ¨ç¨‹åºä¸­æ²¡æœ‰è¢«å¼•ç”¨ï¼Œå®ƒä¼šè¢«"
"åƒåœ¾å›æ”¶å™¨ï¼ˆgarbage collectorï¼‰é”€æ¯ã€‚ ä½¿ç”¨ Hibernate <literal>Session</"
"literal>å¯ä»¥å°†å…¶å˜ä¸ºæŒä¹…ï¼ˆPersistentï¼‰çŠ¶æ€ã€‚ï¼ˆHibernateä¼šè‡ªåŠ¨æ‰§è¡Œå¿…è¦çš„SQLè¯­"
"å¥ï¼‰ "

#. Tag: para
#: session_api.xml:65
#, no-c-format
msgid ""
"<emphasis>Persistent</emphasis> - a persistent instance has a representation "
"in the database and an identifier value. It might just have been saved or "
"loaded, however, it is by definition in the scope of a <literal>Session</"
"literal>. Hibernate will detect any changes made to an object in persistent "
"state and synchronize the state with the database when the unit of work "
"completes. Developers do not execute manual <literal>UPDATE</literal> "
"statements, or <literal>DELETE</literal> statements when an object should be "
"made transient."
msgstr ""
"<emphasis>æŒä¹…ï¼ˆPersistentï¼‰</emphasis> â€” æŒä¹…ï¼ˆPersistentï¼‰çš„å®ä¾‹åœ¨æ•°æ®åº“ä¸­"
"æœ‰å¯¹åº”çš„è®°å½•ï¼Œå¹¶æ‹¥æœ‰ä¸€ä¸ªæŒä¹…åŒ–æ ‡è¯†ï¼ˆidentifierï¼‰ã€‚ æŒä¹…ï¼ˆPersistentï¼‰çš„å®ä¾‹å¯"
"èƒ½æ˜¯åˆšè¢«ä¿å­˜çš„ï¼Œæˆ–åˆšè¢«åŠ è½½çš„ï¼Œæ— è®ºå“ªä¸€ç§ï¼ŒæŒ‰å®šä¹‰ï¼Œå®ƒå­˜åœ¨äºç›¸å…³è”çš„"
"<literal>Session</literal>ä½œç”¨èŒƒå›´å†…ã€‚ Hibernateä¼šæ£€æµ‹åˆ°å¤„äºæŒä¹…"
"ï¼ˆPersistentï¼‰çŠ¶æ€çš„å¯¹è±¡çš„ä»»ä½•æ”¹åŠ¨ï¼Œåœ¨å½“å‰æ“ä½œå•å…ƒï¼ˆunit of workï¼‰æ‰§è¡Œå®Œæ¯•æ—¶"
"å°†å¯¹è±¡æ•°æ®ï¼ˆstateï¼‰ä¸æ•°æ®åº“åŒæ­¥ï¼ˆsynchronizeï¼‰ã€‚ å¼€å‘è€…ä¸éœ€è¦æ‰‹åŠ¨æ‰§è¡Œ"
"<literal>UPDATE</literal>ã€‚å°†å¯¹è±¡ä»æŒä¹…ï¼ˆPersistentï¼‰çŠ¶æ€å˜æˆç¬æ—¶"
"ï¼ˆTransientï¼‰çŠ¶æ€åŒæ ·ä¹Ÿä¸éœ€è¦æ‰‹åŠ¨æ‰§è¡Œ <literal>DELETE</literal> è¯­å¥ã€‚ "

#. Tag: para
#: session_api.xml:77
#, no-c-format
msgid ""
"<emphasis>Detached</emphasis> - a detached instance is an object that has "
"been persistent, but its <literal>Session</literal> has been closed. The "
"reference to the object is still valid, of course, and the detached instance "
"might even be modified in this state. A detached instance can be reattached "
"to a new <literal>Session</literal> at a later point in time, making it (and "
"all the modifications) persistent again. This feature enables a programming "
"model for long running units of work that require user think-time. We call "
"them <emphasis>application transactions</emphasis>, i.e., a unit of work "
"from the point of view of the user."
msgstr ""
"<emphasis>è„±ç®¡ï¼ˆDetachedï¼‰</emphasis> â€” ä¸æŒä¹…ï¼ˆPersistentï¼‰å¯¹è±¡å…³è”çš„"
"<literal>Session</literal>è¢«å…³é—­åï¼Œå¯¹è±¡å°±å˜ä¸ºè„±ç®¡ï¼ˆDetachedï¼‰çš„ã€‚å¯¹è„±ç®¡"
"ï¼ˆDetachedï¼‰å¯¹è±¡çš„å¼•ç”¨ä¾ç„¶æœ‰æ•ˆï¼Œå¯¹è±¡å¯ç»§ç»­è¢«ä¿®æ”¹ã€‚è„±ç®¡ï¼ˆDetachedï¼‰å¯¹è±¡å¦‚æœé‡"
"æ–°å…³è”åˆ°æŸä¸ªæ–°çš„ <literal>Session</literal> ä¸Šï¼Œ ä¼šå†æ¬¡è½¬å˜ä¸ºæŒä¹…"
"ï¼ˆPersistentï¼‰çš„ï¼ˆåœ¨Detachedå…¶é—´çš„æ”¹åŠ¨å°†è¢«æŒä¹…åŒ–åˆ°æ•°æ®åº“ï¼‰ã€‚ è¿™ä¸ªåŠŸèƒ½ä½¿å¾—ä¸€ç§"
"ç¼–ç¨‹æ¨¡å‹ï¼Œå³ä¸­é—´ä¼šç»™ç”¨æˆ·æ€è€ƒæ—¶é—´ï¼ˆuser think-timeï¼‰çš„é•¿æ—¶é—´è¿è¡Œçš„æ“ä½œå•å…ƒ"
"ï¼ˆunit of workï¼‰çš„ç¼–ç¨‹æ¨¡å‹æˆä¸ºå¯èƒ½ã€‚æˆ‘ä»¬ç§°ä¹‹ä¸º<emphasis>åº”ç”¨ç¨‹åºäº‹åŠ¡</"
"emphasis>ï¼Œå³ä»ç”¨æˆ·è§‚ç‚¹çœ‹æ˜¯ä¸€ä¸ªæ“ä½œå•å…ƒï¼ˆunit of workï¼‰ã€‚ "

#. Tag: para
#: session_api.xml:90
#, no-c-format
msgid ""
"We will now discuss the states and state transitions (and the Hibernate "
"methods that trigger a transition) in more detail."
msgstr ""
"æ¥ä¸‹æ¥æˆ‘ä»¬æ¥ç»†è‡´åœ°è®¨è®ºä¸‹çŠ¶æ€ï¼ˆstatesï¼‰åŠçŠ¶æ€é—´çš„è½¬æ¢ï¼ˆstate transitionsï¼‰ï¼ˆä»¥"
"åŠè§¦å‘çŠ¶æ€è½¬æ¢çš„ Hibernate æ–¹æ³•ï¼‰ã€‚ "

#. Tag: title
#: session_api.xml:95
#, no-c-format
msgid "Making objects persistent"
msgstr "ä½¿å¯¹è±¡æŒä¹…åŒ–"

#. Tag: para
#: session_api.xml:97
#, no-c-format
msgid ""
"Newly instantiated instances of a persistent class are considered "
"<emphasis>transient</emphasis> by Hibernate. We can make a transient "
"instance <emphasis>persistent</emphasis> by associating it with a session:"
msgstr ""
"Hibernate è®¤ä¸ºæŒä¹…åŒ–ç±»ï¼ˆpersistent classï¼‰æ–°å®ä¾‹åŒ–çš„å¯¹è±¡æ˜¯<emphasis>ç¬æ—¶"
"ï¼ˆTransientï¼‰</emphasis>çš„ã€‚æˆ‘ä»¬å¯é€šè¿‡å°†ç¬æ—¶ï¼ˆTransientï¼‰å¯¹è±¡ä¸ session å…³è”"
"è€ŒæŠŠå®ƒå˜ä¸º<emphasis>æŒä¹…çš„ï¼ˆPersistentï¼‰</emphasis>ã€‚"

#. Tag: programlisting
#: session_api.xml:102
#, fuzzy, no-c-format
msgid ""
"DomesticCat fritz = new DomesticCat();\n"
"fritz.setColor(Color.GINGER);\n"
"fritz.setSex('M');\n"
"fritz.setName(\"Fritz\");\n"
"Long generatedId = (Long) sess.save(fritz);"
msgstr ""
"<![CDATA[DomesticCat fritz = new DomesticCat();\n"
"fritz.setColor(Color.GINGER);\n"
"fritz.setSex('M');\n"
"fritz.setName(\"Fritz\");\n"
"Long generatedId = (Long) sess.save(fritz);]]>"

#. Tag: para
#: session_api.xml:104
#, no-c-format
msgid ""
"If <literal>Cat</literal> has a generated identifier, the identifier is "
"generated and assigned to the <literal>cat</literal> when <literal>save()</"
"literal> is called. If <literal>Cat</literal> has an <literal>assigned</"
"literal> identifier, or a composite key, the identifier should be assigned "
"to the <literal>cat</literal> instance before calling <literal>save()</"
"literal>. You can also use <literal>persist()</literal> instead of "
"<literal>save()</literal>, with the semantics defined in the EJB3 early "
"draft."
msgstr ""
"å¦‚æœ <literal>Cat</literal> çš„æŒä¹…åŒ–æ ‡è¯†ï¼ˆidentifierï¼‰æ˜¯ <literal>generated</"
"literal> ç±»å‹çš„ï¼Œ é‚£ä¹ˆè¯¥æ ‡è¯†ï¼ˆidentifierï¼‰ä¼šè‡ªåŠ¨åœ¨ <literal>save()</literal> "
"è¢«è°ƒç”¨æ—¶äº§ç”Ÿå¹¶åˆ†é…ç»™ <literal>cat</literal>ã€‚å¦‚æœ <literal>Cat</literal> çš„æŒ"
"ä¹…åŒ–æ ‡è¯†ï¼ˆidentifierï¼‰æ˜¯<literal>assigned</literal>ç±»å‹çš„ï¼Œæˆ–æ˜¯ä¸€ä¸ªå¤åˆä¸»é”®"
"ï¼ˆcomposite keyï¼‰ï¼Œé‚£ä¹ˆè¯¥æ ‡è¯†ï¼ˆidentifierï¼‰åº”å½“åœ¨è°ƒç”¨ <literal>save()</"
"literal> ä¹‹å‰æ‰‹åŠ¨èµ‹äºˆç»™ <literal>cat</literal>ã€‚ä½ ä¹Ÿå¯ä»¥æŒ‰ç…§ EJB3 early "
"draft ä¸­å®šä¹‰çš„è¯­ä¹‰ï¼Œä½¿ç”¨ <literal>persist()</literal> æ›¿ä»£<literal>save()</"
"literal>ã€‚ "

#. Tag: para
#: session_api.xml:115
#, no-c-format
msgid ""
"<literal>persist()</literal> makes a transient instance persistent. However, "
"it does not guarantee that the identifier value will be assigned to the "
"persistent instance immediately, the assignment might happen at flush time. "
"<literal>persist()</literal> also guarantees that it will not execute an "
"<literal>INSERT</literal> statement if it is called outside of transaction "
"boundaries. This is useful in long-running conversations with an extended "
"Session/persistence context."
msgstr ""
"<literal>persist()</literal> ä½¿ä¸€ä¸ªä¸´æ—¶å®ä¾‹æŒä¹…åŒ–ã€‚ç„¶è€Œï¼Œå®ƒä¸ä¿è¯ç«‹å³æŠŠæ ‡è¯†ç¬¦"
"å€¼åˆ†é…ç»™æŒä¹…æ€§å®ä¾‹ï¼Œè¿™ä¼šå‘ç”Ÿåœ¨å†²åˆ·ï¼ˆflushï¼‰çš„æ—¶å€™ã€‚<literal>persist()</"
"literal> ä¹Ÿä¿è¯å®ƒåœ¨äº‹åŠ¡è¾¹ç•Œå¤–è°ƒç”¨æ—¶ä¸ä¼šæ‰§è¡Œ <literal>INSERT</literal> è¯­å¥ã€‚"
"è¿™å¯¹äºé•¿æœŸè¿è¡Œçš„å¸¦æœ‰æ‰©å±•ä¼šè¯/æŒä¹…åŒ–ä¸Šä¸‹æ–‡çš„ä¼šè¯æ˜¯å¾ˆæœ‰ç”¨çš„ã€‚"

#. Tag: para
#: session_api.xml:126
#, no-c-format
msgid ""
"<literal>save()</literal> does guarantee to return an identifier. If an "
"INSERT has to be executed to get the identifier ( e.g. \"identity\" "
"generator, not \"sequence\"), this INSERT happens immediately, no matter if "
"you are inside or outside of a transaction. This is problematic in a long-"
"running conversation with an extended Session/persistence context."
msgstr ""
"<literal>save()</literal> ä¿è¯è¿”å›ä¸€ä¸ªæ ‡è¯†ç¬¦ã€‚å¦‚æœéœ€è¦è¿è¡Œ INSERT æ¥è·å–æ ‡è¯†"
"ç¬¦ï¼ˆå¦‚ \"identity\" è€Œé \"sequence\" ç”Ÿæˆå™¨ï¼‰ï¼Œè¿™ä¸ª INSERT å°†ç«‹å³æ‰§è¡Œï¼Œä¸ç®¡"
"ä½ æ˜¯å¦åœ¨äº‹åŠ¡å†…éƒ¨è¿˜æ˜¯å¤–éƒ¨ã€‚è¿™å¯¹äºé•¿æœŸè¿è¡Œçš„å¸¦æœ‰æ‰©å±•ä¼šè¯/æŒä¹…åŒ–ä¸Šä¸‹æ–‡çš„ä¼šè¯æ¥è¯´"
"ä¼šå‡ºç°é—®é¢˜ã€‚"

#. Tag: para
#: session_api.xml:135
#, no-c-format
msgid ""
"Alternatively, you can assign the identifier using an overloaded version of "
"<literal>save()</literal>."
msgstr "æ­¤å¤–ï¼Œä½ å¯ä»¥ç”¨ä¸€ä¸ªé‡è½½ç‰ˆæœ¬çš„ <literal>save()</literal> æ–¹æ³•ã€‚ "

#. Tag: programlisting
#: session_api.xml:138
#, fuzzy, no-c-format
msgid ""
"DomesticCat pk = new DomesticCat();\n"
"pk.setColor(Color.TABBY);\n"
"pk.setSex('F');\n"
"pk.setName(\"PK\");\n"
"pk.setKittens( new HashSet() );\n"
"pk.addKitten(fritz);\n"
"sess.save( pk, new Long(1234) );"
msgstr ""
"<![CDATA[DomesticCat pk = new DomesticCat();\n"
"pk.setColor(Color.TABBY);\n"
"pk.setSex('F');\n"
"pk.setName(\"PK\");\n"
"pk.setKittens( new HashSet() );\n"
"pk.addKitten(fritz);\n"
"sess.save( pk, new Long(1234) );]]>"

#. Tag: para
#: session_api.xml:140
#, no-c-format
msgid ""
"If the object you make persistent has associated objects (e.g. the "
"<literal>kittens</literal> collection in the previous example), these "
"objects can be made persistent in any order you like unless you have a "
"<literal>NOT NULL</literal> constraint upon a foreign key column. There is "
"never a risk of violating foreign key constraints. However, you might "
"violate a <literal>NOT NULL</literal> constraint if you <literal>save()</"
"literal> the objects in the wrong order."
msgstr ""
"å¦‚æœä½ æŒä¹…åŒ–çš„å¯¹è±¡æœ‰å…³è”çš„å¯¹è±¡ï¼ˆassociated objectsï¼‰ï¼ˆä¾‹å¦‚ä¸Šä¾‹ä¸­çš„ "
"<literal>kittens</literal> é›†åˆï¼‰ é‚£ä¹ˆå¯¹è¿™äº›å¯¹è±¡ï¼ˆè¯‘æ³¨ï¼špk å’Œ kittensï¼‰è¿›è¡ŒæŒ"
"ä¹…åŒ–çš„é¡ºåºæ˜¯ä»»æ„çš„ï¼ˆä¹Ÿå°±æ˜¯è¯´å¯ä»¥å…ˆå¯¹ kittens è¿›è¡ŒæŒä¹…åŒ–ä¹Ÿå¯ä»¥å…ˆå¯¹ pk è¿›è¡ŒæŒä¹…"
"åŒ–ï¼‰ï¼Œ é™¤éä½ åœ¨å¤–é”®åˆ—ä¸Šæœ‰ <literal>NOT NULL</literal> çº¦æŸã€‚ Hibernate ä¸ä¼šè¿"
"åå¤–é”®çº¦æŸï¼Œä½†æ˜¯å¦‚æœä½ ç”¨é”™è¯¯çš„é¡ºåºæŒä¹…åŒ–å¯¹è±¡ï¼ˆè¯‘æ³¨ï¼šåœ¨ pk æŒä¹…åŒ–ä¹‹å‰æŒä¹…åŒ–"
"kittenï¼‰ï¼Œé‚£ä¹ˆå¯èƒ½ä¼šè¿å <literal>NOT NULL</literal> çº¦æŸã€‚ "

#. Tag: para
#: session_api.xml:148
#, no-c-format
msgid ""
"Usually you do not bother with this detail, as you will normally use "
"Hibernate's <emphasis>transitive persistence</emphasis> feature to save the "
"associated objects automatically. Then, even <literal>NOT NULL</literal> "
"constraint violations do not occur - Hibernate will take care of everything. "
"Transitive persistence is discussed later in this chapter."
msgstr ""
"é€šå¸¸ä½ ä¸ä¼šä¸ºè¿™äº›ç»†èŠ‚çƒ¦å¿ƒï¼Œå› ä¸ºä½ å¾ˆå¯èƒ½ä¼šä½¿ç”¨ Hibernate çš„<emphasis>ä¼ æ’­æ€§æŒä¹…"
"åŒ–ï¼ˆtransitive persistenceï¼‰</emphasis>åŠŸèƒ½è‡ªåŠ¨ä¿å­˜ç›¸å…³è”é‚£äº›å¯¹è±¡ã€‚è¿™æ ·è¿è¿"
"å <literal>NOT NULL</literal> çº¦æŸçš„æƒ…å†µéƒ½ä¸ä¼šå‡ºç°äº† â€” Hibernate ä¼šç®¡å¥½æ‰€æœ‰"
"çš„äº‹æƒ…ã€‚ä¼ æ’­æ€§æŒä¹…åŒ–ï¼ˆtransitive persistenceï¼‰å°†åœ¨æœ¬ç« ç¨åè®¨è®ºã€‚"

#. Tag: title
#: session_api.xml:157
#, no-c-format
msgid "Loading an object"
msgstr "è£…è½½å¯¹è±¡"

#. Tag: para
#: session_api.xml:159
#, no-c-format
msgid ""
"The <literal>load()</literal> methods of <literal>Session</literal> provide "
"a way of retrieving a persistent instance if you know its identifier. "
"<literal>load()</literal> takes a class object and loads the state into a "
"newly instantiated instance of that class in a persistent state."
msgstr ""
"å¦‚æœä½ çŸ¥é“æŸä¸ªå®ä¾‹çš„æŒä¹…åŒ–æ ‡è¯†ï¼ˆidentifierï¼‰ï¼Œä½ å°±å¯ä»¥ä½¿ç”¨ <literal>Session</"
"literal> çš„ <literal>load()</literal> æ–¹æ³•æ¥è·å–å®ƒã€‚<literal>load()</"
"literal> çš„å¦ä¸€ä¸ªå‚æ•°æ˜¯æŒ‡å®šç±»çš„å¯¹è±¡ã€‚æœ¬æ–¹æ³•ä¼šåˆ›å»ºæŒ‡å®šç±»çš„æŒä¹…åŒ–å®ä¾‹ï¼Œå¹¶ä»æ•°æ®"
"åº“åŠ è½½å…¶æ•°æ®ï¼ˆstateï¼‰ã€‚ "

#. Tag: programlisting
#: session_api.xml:165
#, fuzzy, no-c-format
msgid "Cat fritz = (Cat) sess.load(Cat.class, generatedId);"
msgstr "<![CDATA[Cat fritz = (Cat) sess.load(Cat.class, generatedId);]]>"

#. Tag: programlisting
#: session_api.xml:167
#, fuzzy, no-c-format
msgid ""
"// you need to wrap primitive identifiers\n"
"long id = 1234;\n"
"DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );"
msgstr ""
"<![CDATA[// you need to wrap primitive identifiers\n"
"long id = 1234;\n"
"DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long"
"(id) );]]>"

#. Tag: para
#: session_api.xml:169
#, no-c-format
msgid "Alternatively, you can load state into a given instance:"
msgstr ""
"æ­¤å¤–ï¼Œä½ å¯ä»¥æŠŠæ•°æ®ï¼ˆstateï¼‰åŠ è½½åˆ°æŒ‡å®šçš„å¯¹è±¡å®ä¾‹ä¸Šï¼ˆè¦†ç›–æ‰è¯¥å®ä¾‹åŸæ¥çš„æ•°æ®ï¼‰ã€‚"

#. Tag: programlisting
#: session_api.xml:171
#, fuzzy, no-c-format
msgid ""
"Cat cat = new DomesticCat();\n"
"// load pk's state into cat\n"
"sess.load( cat, new Long(pkId) );\n"
"Set kittens = cat.getKittens();"
msgstr ""
"<![CDATA[Cat cat = new DomesticCat();\n"
"// load pk's state into cat\n"
"sess.load( cat, new Long(pkId) );\n"
"Set kittens = cat.getKittens();]]>"

#. Tag: para
#: session_api.xml:173
#, no-c-format
msgid ""
"Be aware that <literal>load()</literal> will throw an unrecoverable "
"exception if there is no matching database row. If the class is mapped with "
"a proxy, <literal>load()</literal> just returns an uninitialized proxy and "
"does not actually hit the database until you invoke a method of the proxy. "
"This is useful if you wish to