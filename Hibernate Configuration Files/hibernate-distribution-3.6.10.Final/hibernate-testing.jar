非常有用的。它无需在代码构建时“二进制指令”处理，因此是一个更加值得选择的解决方法。 </p><p>有时你需要在 HQL 中通过<code class="literal">抓取所有属性</code>，强行抓取所有内容。 </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="performance-cache"/>21.2. 二级缓存（The Second Level Cache）</h2></div></div></div><p>Hibernate 的 <code class="literal">Session</code> 在事务级别进行持久化数据的缓存操作。 当然，也有可能分别为每个类（或集合），配置集群、或 JVM 级别（<code class="literal">SessionFactory 级别</code>）的缓存。你甚至可以为之插入一个集群的缓存。注意，缓存永远不知道其他应用程序对持久化仓库（数据库）可能进行的修改 （即使可以将缓存数据设定为定期失效）。 </p><p>You have the option to tell Hibernate which caching implementation to use by specifying the name of a class that implements <code class="literal">org.hibernate.cache.CacheProvider</code> using the property <code class="literal">hibernate.cache.provider_class</code>. Hibernate is bundled with a number of built-in integrations with the open-source cache providers that are listed in <a class="xref" href="performance.html#cacheproviders" title="表 21.1. 缓存策略提供商（Cache Providers）">表 21.1 “缓存策略提供商（Cache Providers）”</a>. You can also implement your own and plug it in as outlined above. Note that versions prior to Hibernate 3.2 use EhCache as the default cache provider.</p><div class="table"><a id="cacheproviders"/><p class="title"><b>表 21.1. 缓存策略提供商（Cache Providers）</b></p><div class="table-contents"><table summary="缓存策略提供商（Cache Providers）" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Cache</th><th align="left">Provider class</th><th align="left">Type</th><th align="left">Cluster Safe</th><th align="left">Query Cache Supported</th></tr></thead><tbody><tr><td align="left">Hashtable （not intended for production use）</td><td align="left"><code class="literal">org.hibernate.cache.HashtableCacheProvider</code></td><td align="left">memory</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><code class="literal">org.hibernate.cache.EhCacheProvider</code></td><td align="left">memory, disk, transactional, clustered</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><code class="literal">org.hibernate.cache.OSCacheProvider</code></td><td align="left">memory，disk</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><code class="literal">org.hibernate.cache.SwarmCacheProvider</code></td><td align="left">clustered (ip multicast)</td><td align="left">yes (clustered invalidation)</td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left"><code class="literal">org.hibernate.cache.TreeCacheProvider</code></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication)</td><td align="left">yes (clock sync req.)</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left"><code class="literal">org.hibernate.cache.jbc.JBossCacheRegionFactory</code></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication or invalidation)</td><td align="left">yes (clock sync req.)</td></tr></tbody></table></div></div><br class="table-break"/><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-mapping"/>21.2.1. 缓存映射（Cache mappings）</h3></div></div></div><p>As we have done in previous chapters we are looking at the two different possibiltites to configure caching. First configuration via annotations and then via Hibernate mapping files.</p><p>By default, entities are not part of the second level cache and we recommend you to stick to this setting. However, you can override this by setting the <code class="literal">shared-cache-mode</code> element in your <code class="filename">persistence.xml</code> file or by using the <code class="literal">javax.persistence.sharedCache.mode </code>property in your configuration. The following values are possible:</p><div class="itemizedlist"><ul><li><p><code class="literal">ENABLE_SELECTIVE</code> (Default and recommended value): entities are not cached unless explicitly marked as cacheable.</p></li><li><p><code class="literal">DISABLE_SELECTIVE</code>: entities are cached unless explicitly marked as not cacheable.</p></li><li><p><code class="literal">ALL</code>: all entities are always cached even if marked as non cacheable.</p></li><li><p><code class="literal">NONE</code>: no entity are cached even if marked as cacheable. This option can make sense to disable second-level cache altogether.</p></li></ul></div><p>The cache concurrency strategy used by default can be set globaly via the <code class="literal">hibernate.cache.default_cache_concurrency_strategy</code> configuration property. The values for this property are:</p><div class="itemizedlist"><ul><li><p><code class="literal">read-only</code></p></li><li><p><code class="literal">read-write</code></p></li><li><p><code class="literal">nonstrict-read-write</code></p></li><li><p><code class="literal">transactional</code></p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>It is recommended to define the cache concurrency strategy per entity rather than using a global one. Use the <code class="classname">@org.hibernate.annotations.Cache</code> annotation for that.</p></div><div class="example"><a id="example-cache-concurrency-with-cache-annotation"/><p class="title"><b>例 21.5. Definition of cache concurrency strategy via <code class="classname">@Cache</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Entity</span><!-- <br/> --><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cacheable</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cache</span><span class="java_separator">(</span><span class="java_plain">usage&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheConcurrencyStrategy</span><span class="java_separator">.</span><span class="java_plain">NONSTRICT_READ_WRITE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">Forest</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;</span><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>Hibernate also let's you cache the content of a collection or the identifiers if the collection contains other entities. Use the <code class="classname">@Cache</code> annotation on the collection property.</p><div class="example"><a id="d0e19044"/><p class="title"><b>例 21.6. Caching collections using annotations</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">OneToMany</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">cascade</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_type">CascadeType</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">ALL</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;fetch</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_type">FetchType</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">EAGER</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">JoinColumn</span><span class="java_separator">(</span><span class="java_plain">name</span><span class="java_operator">=</span><span class="java_literal">&quot;CUST_ID&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cache</span><span class="java_separator">(</span><span class="java_plain">usage&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheConcurrencyStrategy</span><span class="java_separator">.</span><span class="java_plain">NONSTRICT_READ_WRITE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">SortedSet</span><span class="java_operator">&lt;</span><span class="java_type">Ticket</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;getTickets</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;tickets</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p><a class="xref" href="performance.html#example-cache-annotation-with-attributes" title="例 21.7. @Cache annotation with attributes">例 21.7 “@Cache annotation with attributes”</a>shows the<code class="literal"> @org.hibernate.annotations.Cache</code> annotations with its attributes. It allows you to define the caching strategy and region of a given second level cache.</p><div class="example"><a id="example-cache-annotation-with-attributes"/><p class="title"><b>例 21.7. <code class="classname">@Cache</code> annotation with attributes</b></p><div class="example-contents"><div class="programlistingco"><pre class="programlisting">@Cache(
    CacheConcu<span xmlns="" class="co" id="cache-hm1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>rrencyStrategy usage();
    String reg<span xmlns="" class="co" id="cache-hm2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>ion() default "";
    String inc<span xmlns="" class="co" id="cache-hm3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>lude() default "all";
)</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p>usage: the given cache concurrency strategy (NONE, READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL)</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p>region (optional): the cache region (default to the fqcn of the class or the fq role name of the collection)</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">include</code> (optional): all to include all properties, non-lazy to only include non lazy properties (default all).</p></td></tr></table></div></div></div></div><br class="example-break"/><p>Let's now take a look at Hibernate mapping files. There the <code class="literal">&lt;cache&gt;</code> element of a class or collection mapping is used to configure the second level cache. Looking at <a class="xref" href="performance.html#example-hibernate-cache-mapping-element" title="例 21.8. The Hibernate &lt;cache&gt; mapping element">例 21.8 “The Hibernate &lt;cache&gt; mapping element”</a> the parallels to anotations is obvious.</p><div class="example"><a id="example-hibernate-cache-mapping-element"/><p class="title"><b>例 21.8. The Hibernate <code class="literal">&lt;cache&gt;</code> mapping element</b></p><div class="example-contents"><div class="programlistingco"><pre class="programlisting">&lt;cache
    usage="tra<span xmlns="" class="co" id="cache1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>nsactional|read-write|nonstrict-read-write|read-only"
    region="Re<span xmlns="" class="co" id="cache2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>gionName"
    include="a<span xmlns="" class="co" id="cache3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>ll|non-lazy"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">usage</code>（必须）说明了缓存的策略：<code class="literal">transactional</code>、 <code class="literal">read-write</code>、<code class="literal">nonstrict-read-write</code> 或 <code class="literal">read-only</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">region</code> （可选，默认为类或者集合的名字（class or collection role name）） 指定第二级缓存的区域名（name of the second level cache region） </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">include</code>（可选,默认为 <code class="literal">all</code>） <code class="literal">non-lazy</code> 当属性级延迟抓取打开时，标记为 <code class="literal">lazy="true"</code> 的实体的属性可能无法被缓存 </p></td></tr></table></div></div></div></div><br class="example-break"/><p>Alternatively to <code class="literal">&lt;cache&gt;</code>, you can use <code class="literal">&lt;class-cache&gt;</code> and <code class="literal">&lt;collection-cache&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code>.</p><p>Let's now have a closer look at the different usage strategies</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readonly"/>21.2.2. 策略：只读缓存（Strategy：read only）</h3></div></div></div><p>如果你的应用程序只需读取一个持久化类的实例，而无需对其修改， 那么就可以对其进行<code class="literal">只读</code> 缓存。这是最简单，也是实用性最好的方法。甚至在集群中，它也能完美地运作。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readwrite"/>21.2.3. 策略：读写/缓存（Strategy：read/write）</h3></div></div></div><p>如果应用程序需要更新数据，那么使用<code class="literal">读/写缓存</code> 比较合适。 如果应用程序要求“序列化事务”的隔离级别（serializable transaction isolation level），那么就决不能使用这种缓存策略。 如果在 JTA 环境中使用缓存，你必须指定 <code class="literal">hibernate.transaction.manager_lookup_class</code> 属性的值， 通过它，Hibernate 才能知道该应用程序中 JTA 的<code class="literal">TransactionManager</code>的具体策略。 在其它环境中，你必须保证在 <code class="literal">Session.close()</code>、或 <code class="literal">Session.disconnect()</code> 调用前， 整个事务已经结束。 如果你想在集群环境中使用此策略，你必须保证底层的缓存实现支持锁定（locking）。Hibernate 内置的缓存策略并不支持锁定功能。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-nonstrict"/>21.2.4. 策略：非严格读/写缓存（Strategy：nonstrict read/write）</h3></div></div></div><p>如果应用程序只偶尔需要更新数据（也就是说，两个事务同时更新同一记录的情况很不常见），也不需要十分严格的事务隔离，那么比较适合使用<code class="literal">非严格读/写缓存</code>策略。如果在 JTA 环境中使用该策略，你必须为其指定 <code class="literal">hibernate.transaction.manager_lookup_class</code> 属性的值，在其它环境中，你必须保证在<code class="literal">Session.close()</code>、或 <code class="literal">Session.disconnect()</code> 调用前，整个事务已经结束。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-transactional"/>21.2.5. 策略：事务缓存（transactional）</h3></div></div></div><p>Hibernate 的<code class="literal">事务缓存</code>策略提供了全事务的缓存支持，例如对 JBoss TreeCache 的支持。这样的缓存只能用于 JTA 环境中，你必须指定为其  <code class="literal">hibernate.transaction.manager_lookup_class</code> 属性。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-compat-matrix"/>21.2.6. 各种缓存提供商/缓存并发策略的兼容性</h3></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要</h2><p>没有一种缓存提供商能够支持上列的所有缓存并发策略。下表中列出了各种提供器、及其各自适用的并发策略。 </p></div><p>没有一种缓存提供商能够支持上列的所有缓存并发策略。下表中列出了各种提供器、及其各自适用的并发策略。 </p><div class="table"><a id="d0e19216"/><p class="title"><b>表 21.2. 各种缓存提供商对缓存并发策略的支持情况（Cache Concurrency Strategy Support）</b></p><div class="table-contents"><table summary="各种缓存提供商对缓存并发策略的支持情况（Cache Concurrency Strategy Support）" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable （not intended for production use）</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="performance-sessioncache"/>21.3. 管理缓存（Managing the caches）</h2></div></div></div><p>无论何时，当你给 <code class="literal">save()</code>、<code class="literal">update()</code> 或  <code class="literal">saveOrUpdate()</code> 方法传递一个对象时，或使用 <code class="literal">load()</code>、<code class="literal">get()</code>、<code class="literal">list()</code>、<code class="literal">iterate()</code> 或 <code class="literal">scroll()</code> 方法获得一个对象时，该对象都将被加入到 <code class="literal">Session</code> 的内部缓存中。 </p><p>当随后 flush() 方法被调用时，对象的状态会和数据库取得同步。如果你不希望此同步操作发生，或者你正处理大量对象、需要对有效管理内存时，你可以调用 <code class="literal">evict()</code> 方法，从一级缓存中去掉这些对象及其集合。 </p><div class="example"><a id="d0e19333"/><p class="title"><b>例 21.9. Explcitly evicting a cached instance from the first level cache using <code class="methodname">Session.evict()</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">ScrollableResult</span><!-- <br/> --><span class="java_plain">&nbsp;cats&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;Cat&nbsp;as&nbsp;cat&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">scroll</span><!-- <br/> --><span class="java_separator">();</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">a&nbsp;huge&nbsp;result&nbsp;set</span>
<!--  --><br/><span class="java_keyword">while</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;cats</span><span class="java_separator">.</span><span class="java_plain">next</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cat</span><span class="java_plain">&nbsp;cat&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;cats</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_literal">0</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;doSomethingWithACat</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">evict</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>Session 还提供了一个 <code class="literal">contains()</code> 方法，用来判断某个实例是否处于当前 session 的缓存中。</p><p>如若要把所有的对象从 session 缓存中彻底清除，则需要调用 <code class="literal">Session.clear()</code>。 </p><p>对于二级缓存来说，在 <code class="literal">SessionFactory</code> 中定义了许多方法，清除缓存中实例、整个类、集合实例或者整个集合。</p><div class="example"><a id="d0e19355"/><p class="title"><b>例 21.10. Second-level cache eviction via <code class="methodname">SessionFactoty.evict() </code>and <code class="methodname">SessionFacyory.evictCollection()</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">evict</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;catId</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">evict&nbsp;a&nbsp;particular&nbsp;</span><!-- <br/> --><span class="java_type">Cat</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evict</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;all&nbsp;</span><span class="java_type">Cats</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evictCollection</span><span class="java_separator">(</span><span class="java_literal">&quot;Cat.kittens&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;catId</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;a&nbsp;particular&nbsp;collection&nbsp;of&nbsp;kittens</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evictCollection</span><span class="java_separator">(</span><span class="java_literal">&quot;Cat.kittens&quot;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;all&nbsp;kitten&nbsp;collections</span></pre></div></div><br class="example-break"/><p><code class="literal">CacheMode</code> 参数用于控制具体的 Session 如何与二级缓存进行交互。 </p><div class="itemizedlist"><ul><li><p><code class="literal">CacheMode.NORMAL</code>：从二级缓存中读、写数据。</p></li><li><p><code class="literal">CacheMode.GET</code>：从二级缓存中读取数据，仅在数据更新时对二级缓存写数据。</p></li><li><p><code class="literal">CacheMode.PUT</code>：仅向二级缓存写数据，但不从二级缓存中读数据。</p></li><li><p><code class="literal">CacheMode.REFRESH</code>：仅向二级缓存写数据，但不从二级缓存中读数据。通过 <code class="literal">hibernate.cache.use_minimal_puts</code> 的设置，强制二级缓存从数据库中读取数据，刷新缓存内容。</p></li></ul></div><p>如若需要查看二级缓存或查询缓存区域的内容，你可以使用<code class="literal">统计（Statistics）</code> API。</p><div class="example"><a id="d0e19398"/><p class="title"><b>例 21.11. Browsing the second-level cache entries via the <code class="classname">Statistics</code> API</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Map</span><!-- <br/> --><span class="java_plain">&nbsp;cacheEntries&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getStatistics</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">getSecondLevelCacheStatistics</span><span class="java_separator">(</span><span class="java_plain">regionName</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">getEntries</span><span class="java_separator">();</span></pre></div></div><br class="example-break"/><p>此时，你必须手工打开统计选项。可选的，你可以让 Hibernate 更人工可读的方式维护缓存内容。 </p><div class="example"><a id="d0e19408"/><p class="title"><b>例 21.12. Enabling Hibernate statistics</b></p><div class="example-contents"><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div></div><br class="example-break"/></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="performance-querycache"/>21.4. 查询缓存（The Query Cache）</h2></div></div></div><p>查询的结果集也可以被缓存。只有当经常使用同样的参数进行查询时，这才会有些用处。</p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-querycache-enable"/>21.4.1. 启用查询缓存</h3></div></div></div><p>按照应用程序的事务性处理过程，查询结果的缓存将产生一些负荷。例如，如果缓存针对 Person 的查询结果，在 Person 发生了修改时，Hibernate 将需要跟踪这些结果什么时候失效。因为大多数应用程序不会从缓存查询结果中受益，所以 Hibernate 在缺省情况下将禁用缓存。要使用查询缓存，你首先需要启用查询缓存：</p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>这个设置创建了两个新的缓存 region： </p><div class="itemizedlist"><ul><li><p><code class="classname">org.hibernate.cache.StandardQueryCache</code>，保存缓存的查询结果</p></li><li><p><code class="classname">org.hibernate.cache.UpdateTimestampsCache</code>，保存对可查询表的最近更新的时间戳。它们用于检验查询结果。</p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要</h2><p>If you configure your underlying cache implementation to use expiry or timeouts is very important that the cache timeout of the underlying cache region for the UpdateTimestampsCache be set to a higher value than the timeouts of any of the query caches. In fact, we recommend that the the UpdateTimestampsCache region not be configured for expiry at all. Note, in particular, that an LRU cache expiry policy is never appropriate.</p></div><p>如上面所提及的，绝大多数的查询并不能从查询缓存中受益，所以 Hibernate 默认是不进行查询缓存的。如若需要进行缓存，请调用 <code class="literal">org.hibernate.Query.setCacheable（true）</code>方法。这个调用会让查询在执行过程中时先从缓存中查找结果，并将自己的结果集放到缓存中去。 </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>查询缓存不会缓存缓存中实际实体的状态；它只缓存标识符值和值类型的结果。出于这个原因，对于那些作为查询结果缓存的一部分（和集合缓存一样）进行缓存的实体，查询缓存应该和二级缓存一起使用。</p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-querycache-regions"/>21.4.2. 查询缓存区</h3></div></div></div><p>如果你要对查询缓存的失效政策进行精确的控制，你必须调用 <code class="literal">Query.setCacheRegion()</code> 方法，为每个查询指定其命名的缓存区域。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">List</span><!-- <br/> --><span class="java_plain">&nbsp;blogs&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;Blog&nbsp;blog&nbsp;where&nbsp;blog.blogger&nbsp;=&nbsp;:blogger&quot;</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setEntity</span><span class="java_separator">(</span><span class="java_literal">&quot;blogger&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;blogger</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setMaxResults</span><span class="java_separator">(</span><span class="java_literal">15</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setCacheable</span><span class="java_separator">(</span><span class="java_literal">true</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setCacheRegion</span><span class="java_separator">(</span><span class="java_literal">&quot;frontpages&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>如果查询需要强行刷新其查询缓存区域，那么你应该调用 <code class="literal">org.hibernate.Query.setCacheMode（CacheMode.REFRESH）</code>方法。 这对在其他进程中修改底层数据（例如，不通过Hibernate修改数据），或对那些需要选择性更新特定查询结果集的情况特别有用。这是对 <code class="literal">org.hibernate.SessionFactory.evictQueries()</code> 的更为有效的替代方案，同样可以清除查询缓存区域。</p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="performance-collections"/>21.5. 理解集合性能（Understanding Collection performance）</h2></div></div></div><p>在前面的章节里我们已经讨论了集合和相关应用程序。在本节我么将探索运行时集合的更多问题。</p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-taxonomy"/>21.5.1. 分类（Taxonomy）</h3></div></div></div><p>Hibernate 定义了三种基本类型的集合：</p><div class="itemizedlist"><ul><li><p>值数据集合</p></li><li><p>一对多关联（One-to-many Associations） </p></li><li><p>多对多关联 </p></li></ul></div><p>这个分类是区分了不同的表和外键关系类型，但是它没有告诉我们关系模型的所有内容。 要完全理解他们的关系结构和性能特点，我们必须同时考虑“用于 Hibernate 更新或删除集合行数据的主键的结构”。因此得到了如下的分类：</p><div class="itemizedlist"><ul><li><p>有序集合类</p></li><li><p>集合（sets）</p></li><li><p>包（bags）</p></li></ul></div><p>所有的有序集合类（maps，lists，arrays）都拥有一个由 <code class="literal">&lt;key&gt;</code> 和 <code class="literal">&lt;index&gt;</code> 组成的主键。这种情况下集合类的更新是非常高效的 — 主键已经被有效的索引，因此当 Hibernate 试图更新或删除一行时，可以迅速找到该行数据。 </p><p>集合（sets）的主键由 <code class="literal">&lt;key&gt;</code> 和其他元素字段构成。对于有些元素类型来说，这很低效，特别是组合元素或者大文本、大二进制字段；数据库可能无法有效的对复杂的主键进行索引。另一方面，对于一对多、多对多关联，特别是合成的标识符来说，集合也可以达到同样的高效性能。（ 附注：如果你希望 <code class="literal">SchemaExport</code> 为你的 <code class="literal">&lt;set&gt;</code> 创建主键，你必须把所有的字段都声明为 <code class="literal">not-null="true"</code>。） </p><p><code class="literal">&lt;idbag&gt;</code> 映射定义了代理键，因此它总是可以很高效的被更新。事实上，<code class="literal">&lt;idbag&gt;</code> 拥有着最好的性能表现。 </p><p>Bag 是最差的。因为 bag 允许重复的元素值，也没有索引字段，因此不可能定义主键。 Hibernate 无法判断出重复的行。当这种集合被更改时，Hibernate 将会先完整地移除 （通过一个（in a single <code class="literal">DELETE</code>））整个集合，然后再重新创建整个集合。因此 Bag 是非常低效的。 </p><p>请注意：对于一对多关联来说，“主键”很可能并不是数据库表的物理主键。但就算在此情况下，上面的分类仍然是有用的。（它仍然反映了 Hibernate 在集合的各数据行中是如何进行“定位”的。） </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficientupdate"/>21.5.2. Lists，maps 和 sets 用于更新效率最高</h3></div></div></div><p>根据我们上面的讨论，显然有序集合类型和大多数 set 都可以在增加、删除、修改元素中拥有最好的性能。 </p><p>可论证的是对于多对多关联、值数据集合而言，有序集合类比集合（set）有一个好处。因为 <code class="literal">Set</code> 的内在结构， 如果“改变”了一个元素，Hibernate 并不会<code class="literal">更新（UPDATE）</code>这一行。对于 <code class="literal">Set</code> 来说，只有在<code class="literal">插入（INSERT）</code>和<code class="literal">删除（DELETE）</code> 操作时“改变”才有效。再次强调：这段讨论对“一对多关联”并不适用。 </p><p>注意到数组无法延迟载入，我们可以得出结论，list，map 和 idbags 是最高效的（非反向）集合类型，set 则紧随其后。 在 Hibernate 中，set 应该时最通用的集合类型，这时因为“set”的语义在关系模型中是最自然的。 </p><p>但是，在设计良好的 Hibernate 领域模型中，我们通常可以看到更多的集合事实上是带有  <code class="literal">inverse="true"</code> 的一对多的关联。对于这些关联，更新操作将会在多对一的这一端进行处理。因此对于此类情况，无需考虑其集合的更新性能。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficentinverse"/>21.5.3. Bag 和 list 是反向集合类中效率最高的</h3></div></div></div><p>在把 bag 扔进水沟之前，你必须了解，在一种情况下，bag 的性能（包括list）要比 set 高得多：对于指明了 <code class="literal">inverse="true"</code> 的集合类（比如说，标准的双向的一对多关联），我们可以在未初始化（fetch）包元素的情况下直接向 bag 或 list 添加新元素！ 这是因为 <code class="literal">Collection.add()</code>）或者 <code class="literal">Collection.addAll()</code> 方法对 bag 或者 List 总是返回 true（这点与与 Set 不同）。因此对于下面的相同代码来说，速度会快得多。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">c</span><span class="java_separator">.</span><span class="java_plain">setParent</span><span class="java_separator">(</span><span class="java_plain">p</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">no&nbsp;need&nbsp;to&nbsp;fetch&nbsp;the&nbsp;collection</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_plain">sess</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-oneshotdelete"/>21.5.4. 一次性删除（One shot delete）</h3></div></div></div><p>偶尔的，逐个删除集合类中的元素是相当低效的。Hibernate 并没那么笨，如果你想要把整个集合都删除（比如说调用 list.clear()），Hibernate 只需要一个 DELETE 就搞定了。 </p><p>假设我们在一个长度为20的集合类中新增加了一个元素，然后再删除两个。Hibernate 会安排一条 <code class="literal">INSERT</code> 语句和两条 <code class="literal">DELETE</code> 语句（除非集合类是一个 bag）。这当然是令人满意的。 </p><p>但是，假设我们删除了 18 个数据，只剩下 2 个，然后新增 3 个。则有两种处理方式：</p><div class="itemizedlist"><ul><li><p>逐一的删除这 18 个数据，再新增三个；</p></li><li><p>删除整个集合类（只用一句 DELETE 语句），然后逐一添加 5 个数据。</p></li></ul></div><p>Hibernate 还没那么聪明，知道第二种选择可能会比较快。（也许让 Hibernate 不这么聪明也是好事，否则可能会引发意外的“数据库触发器”之类的问题。）</p><p>幸运的是，你可以强制使用第二种策略。你需要取消原来的整个集合类（解除其引用），然后再返回一个新的实例化的集合类，只包含需要的元素。有些时候这是非常有用的。 </p><p>显然，一次性删除并不适用于被映射为 <code class="literal">inverse="true"</code> 的集合。 </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="performance-monitoring"/>21.6. 监测性能（Monitoring performance）</h2></div></div></div><p>没有监测和性能参数而进行优化是毫无意义的。Hibernate 为其内部操作提供了一系列的示意图，因此可以从 每个 <code class="literal">SessionFactory</code> 抓取其统计数据。</p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-sf"/>21.6.1. 监测 SessionFactory</h3></div></div></div><p>你可以有两种方式访问 <code class="literal">SessionFactory</code> 的数据记录，第一种就是自己直接调用 <code class="literal">sessionFactory.getStatistics()</code> 方法读取、显示<code class="literal">统计</code>数据。</p><p>此外，如果你打开 <code class="literal">StatisticsService</code> MBean 选项，那么 Hibernate 则可以使用 JMX 技术 发布其数据记录。你可以让应用中所有的 <code class="literal">SessionFactory</code> 同时共享一个 MBean，也可以每个 SessionFactory 分配一个 MBean。下面的代码即是其演示代码： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">MBean</span><!-- <br/> --><span class="java_plain">&nbsp;service&nbsp;registration&nbsp;</span><!-- <br/> --><span class="java_keyword">for</span><!-- <br/> --><span class="java_plain">&nbsp;a&nbsp;specific&nbsp;</span><!-- <br/> --><span class="java_type">SessionFactory</span>
<!--  --><br/><span class="java_type">Hashtable</span><span class="java_plain">&nbsp;tb&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Hashtable</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;type&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;statistics&quot;</span><span class="java_separator