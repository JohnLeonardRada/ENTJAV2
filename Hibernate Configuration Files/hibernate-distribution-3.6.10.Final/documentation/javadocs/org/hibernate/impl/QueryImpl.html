n>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>No verá estos pedazos de código en una aplicación normal; las excepciones fatales (del sistema) siempre deben ser capturadas en la "cima". En otras palabras, el código que ejecuta las llamadas de Hibernate en la capa de persistencia y el código que maneja <code class="literal">RuntimeException</code> (y usualmente sólo puede limpiar y salir) se encuentran en capas diferentes. La administración de contexto actual de Hibernate puede simplificar de manera importante este diseño, ya que todo lo que necesita hacer es acceder a <code class="literal">SessionFactory</code>. El manejo de excepciones se discute más adelante en este capítulo. </p><p>Debe seleccionar <code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code>, el cual es el predeterminado, y para el segundo ejemplo seleccionar <code class="literal">"thread"</code> como su <code class="literal">hibernate.current_session_context_class</code>. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-jta"/>13.2.2. Utilización de JTA</h3></div></div></div><p>Si su capa de persistencia se ejecuta en un servidor de aplicaciones (por ejemplo, detrás de los beans de sesión EJB), cada conexión de fuente de datos obtenida por Hibernate será parte de la transacción JTA global de manera automática. También puede instalar una implementación JTA autónoma y utilizarla sin EJB. Hibernate ofrece dos estrategias para esta integración JTA. </p><p>Si usa transacciones gestionadas-por-bean (BMT) Hibernate le dirá al servidor de aplicaciones que comience y finalice una transacción BMT si usa la API de <code class="literal">Transaction</code>. De modo que, el código de gestión de la transacción es idéntico al de un entorno no administrado.  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Si quiere utilizar un vínculo de transacción <code class="literal">Session</code>, es decir, la funcionalidad <code class="literal">getCurrentSession()</code> para propagación de contexto de manera fácil, tendrá que utilizar el API <code class="literal">UserTransaction</code> del JTA directamente:  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">UserTransaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">UserTransaction</span><span class="java_separator">)</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">InitialContext</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">lookup</span><span class="java_separator">(</span><span class="java_literal">&quot;java:comp/UserTransaction&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Do</span><span class="java_plain">&nbsp;some&nbsp;work&nbsp;on&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;bound&nbsp;to&nbsp;transaction</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">load</span><span class="java_separator">(...);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">persist</span><span class="java_separator">(...);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Con CMT, la demarcación de transacción se realiza en los descriptores de implementacion bean de sesión, no programáticamente. Por lo tanto el código se reduce a: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;CMT&nbsp;idiom</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">...</span>
</pre><p>En un CMT/EJB incluso el deshacer sucede de forma automática. Un <code class="literal">RuntimeException</code> lanzado por un método bean de sesión le dice al contenedor que establezca una transacción global para deshacer. <span class="emphasis"><em>No necesita utilizar el API <code class="literal">Transaction</code> de Hibernate con BMT o CMT y obtiene la propagación automática de sesión"actual" vinculada a la transacción.</em></span> </p><p>Al configurar la fábrica de transacciones de Hibernate, escoja <code class="literal">org.hibernate.transaction.JTATransactionFactory</code> si utiliza JTA directamente (BMT) y <code class="literal">org.hibernate.transaction.CMTTransactionFactory</code> en una bean de sesión CMT. Recuerde establecer también <code class="literal">hibernate.transaction.manager_lookup_class</code>. Asegúrese de que su <code class="literal">hibernate.current_session_context_class</code> no se encuentra configurado (compatibilidad retrasada) o configurada como <code class="literal">"jta"</code>. </p><p>La operación <code class="literal">getCurrentSession()</code> tiene un inconveniente en un entorno JTA. Hay una desventaja en el uso del modo de liberación de la conección <code class="literal">after_statement</code>, la cual luego se utiliza por defecto. Debido a una limitación de la especificación JTA, no le es posible a Hibernate limpiar automáticamente cualquier instancia <code class="literal">ScrollableResults</code> o <code class="literal">Iterator</code> no cerradas y retornadas por <code class="literal">scroll()</code> o <code class="literal">iterate()</code>. <span class="emphasis"><em>Tiene</em></span> que liberar el cursor de la base de datos subyacente llamando a <code class="literal">ScrollableResults.close()</code> o <code class="literal">Hibernate.close(Iterator)</code> explícitamente desde un bloque <code class="literal">finally</code>. La mayoría de las aplicaciones pueden evitar fácilmente el utilizar <code class="literal">scroll()</code> o <code class="literal">iterate()</code> del código JTA o CMT. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-exceptions"/>13.2.3. Manejo de excepciones</h3></div></div></div><p>Si la <code class="literal">Session</code> lanza una excepción, incluyendo cualquier <code class="literal">SQLException</code>, debe deshacer inmediatamente la transacción de la base de datos, llamar a <code class="literal">Session.close()</code> y descartar la instancia de <code class="literal">Session</code>. Ciertos métodos de <code class="literal">Session</code> <span class="emphasis"><em>no</em></span> dejarán la sesión en un estado consistente. Ninguna excepción lanzada por Hibernate puede ser tratada como recuperable. Asegúrese de que la <code class="literal">Session</code> se cierre llamando a <code class="literal">close()</code> en un bloque <code class="literal">finally</code>. </p><p>La <code class="literal">HibernateException</code>, que envuelve a la mayoría de los errores que pueden ocurrir en la capa de persistencia de Hibernate, es una excepción no chequeada. No lo era en versiones anteriores de Hibernate. En nuestra opinión, no debemos forzar al desarrollador de aplicaciones a capturar una excepción irrecuperable en una capa baja. En la mayoría de los sistemas, las excepciones no chequeadas y fatales son manejadas en uno de los primeros cuadros de la pila de llamadas a métodos (por ejemplo, en las capas más altas) y presenta un mensaje de error al usuario de la aplicación o se toma alguna otra acción apropiada. Note que Hibernate podría también lanzar otras excepciones no chequeadas que no sean una <code class="literal">HibernateException</code>. Estas no son recuperables y debe tomarse una acción apropiada. </p><p>Hibernate envuelve <code class="literal">SQLException</code>s lanzadas mientras se interactúa con la base de datos en una <code class="literal">JDBCException</code>. De hecho, Hibernate intentará convertir la excepción en una subclase de <code class="literal">JDBCException</code> más significativa. La <code class="literal">SQLException</code> subyacente siempre está disponible por medio de <code class="literal">JDBCException.getCause()</code>. Hibernate convierte la <code class="literal">SQLException</code> en una subclase de <code class="literal">JDBCException</code> apropiada usando el <code class="literal">SQLExceptionConverter</code> adjunto a la <code class="literal">SessionFactory</code>. Por defecto, el <code class="literal">SQLExceptionConverter</code> está definido por el dialecto configurado. Sin embargo, también es posible enchufar una implementación personalizada . Consulte los javadocs de la clase <code class="literal">SQLExceptionConverterFactory</code> para obtener más detalles. Los subtipos estándar de <code class="literal">JDBCException</code> son:  </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">JDBCConnectionException</code>: indica un error con la comunicación JDBC subyacente. </p></li><li><p><code class="literal">SQLGrammarException</code>: indica un problema de gramática o sintáxis con el SQL publicado. </p></li><li><p><code class="literal">ConstraintViolationException</code>: indica alguna forma de violación de restricción de integridad. </p></li><li><p><code class="literal">LockAcquisitionException</code>: indica un error adquiriendo un nivel de bloqueo necesario para realizar una operación solicitada. </p></li><li><p><code class="literal">GenericJDBCException</code>: una excepción genérica que no encajó en ninguna de las otras categorías. </p></li></ul></div></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-timeout"/>13.2.4. Tiempo de espera de la transacción</h3></div></div></div><p>Una característica importante proporcionada por un entorno administrado como EJB que nunca es proporcionado para un código no-administrado, es el tiempo de espera de la transacción. Estos tiempos de espera se aseguran de que ninguna transacción que se comporte inapropiadamente pueda vincular recursos mientras no devuelva una respuesta al usuario. Fuera de un entorno administrado (JTA), Hibernate no puede proporcionar completamente esta funcionalidad. Sin embargo, Hibernate puede por lo menos controlar las operaciones de acceso de datos, asegurándose de que los bloqueos a nivel de base de datos y las consultas con grandes grupos de resultados se encuentran limitados por un tiempo de espera definido. En un entorno administrado, Hibernate puede delegar el tiempo de espera de la transacción a JTA. Esta funcionalidad es abstraída por el objeto <code class="literal">Transaction</code> de Hibernate. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">set&nbsp;transaction&nbsp;timeout&nbsp;to&nbsp;</span><span class="java_literal">3</span><span class="java_plain">&nbsp;seconds</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">setTimeout</span><span class="java_separator">(</span><span class="java_literal">3</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p><code class="literal">setTimeout()</code> no se puede llamar en un bean CMT, en donde se deben definir declarativamente los tiempos de espera de las transacciones. </p></div></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic"/>13.3. Control de concurrencia optimista</h2></div></div></div><p>El único enfoque consistente con una alta concurrencia y una alta escalabilidad es el control de concurrencia optimista con versionamiento. El chequeo de versión utiliza números de versión, o sellos de fecha (timestamps), para detectar actualizaciones en conflicto y para prevenir la pérdida de actualizaciones. Hibernate proporciona tres enfoques posibles de escribir código de aplicación que utilice concurrencia optimista. Los casos de uso que mostramos se encuentran en el contexto de conversaciones largas, pero el chequeo de versiones tiene además el beneficio de prevenir la pérdida de actualizaciones en transacciones individuales de la base de datos. </p><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-manual"/>13.3.1. Chequeo de versiones de la aplicación</h3></div></div></div><p>En una implementación que no tiene mucha ayuda de Hibernate, cada interacción con la base de datos ocurre en una nueva <code class="literal">Session</code> y el desarrollador es el responsable de recargar todas las intancias persistentes desde la base de datos antes de manipularlas. Este enfoque fuerza a la aplicación a realizar su propio chequeo de versiones para asegurar el aislamiento de transacciones de conversaciones. Este enfoque es el menos eficiente en términos de acceso a la base de datos. Es el enfoque más similar a los EJBs de entidad. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;</span><!-- <br/> --><span class="java_type">Session</span>
<!--  --><br/><span class="java_plain">session&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">int</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">load</span><span class="java_separator">(</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">,</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getKey</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;load&nbsp;the&nbsp;current&nbsp;state</span>
<!--  --><br/><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StaleObjectStateException</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p>La propiedad <code class="literal">version</code> se mapea utilizando <code class="literal">&lt;version&gt;</code>, e Hibernate la incrementará automáticamente durante la limpieza si la entidad está desactualizada. </p><p>Si está operando un entorno de baja-concurrencia-de-datos y no requiere chequeo de versiones, puede usar este enfoque y simplemente saltarse el chequeo de versiones. En ese caso, <span class="emphasis"><em>el último que guarda gana</em></span> y será la estrategia por defecto para conversaciones largas. Tenga en mente que esto podría confundir a los usuarios de la aplicación, pues podrían experimentar pérdidas de actualizaciones sin mensajes de error ni oportunidad de fusionar los cambios conflictivos. </p><p>El chequeo manual de versiones es factible sólamente en circunstancias muy triviales y no es práctico para la mayoría de las aplicaciones. Con frecuencia se tienen que chequear no sólamente las intancias sólas, sino también grafos completos de objetos modificados. Hibernate ofrece el chequeo de versiones automático con el paradigma de diseño de <code class="literal">Session</code> larga o de instancias separadas. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-longsession"/>13.3.2. Sesión extendida y versionado automático</h3></div></div></div><p>Una sóla instancia de <code class="literal">Session</code> y sus instancias persistentes se utilizan para toda la convervsación conocida como <span class="emphasis"><em>sesión-por-conversación</em></span>. Hibernate chequea las versiones de instancia en el momento de vaciado, lanzando una excepción si se detecta una modificación concurrente. Le concierne al desarrollador capturar y manejar esta excepción. Las opciones comunes son la oportunidad del usuario de fusionar los cambios, o de recomenzar el proceso empresarial sin datos desactualizados. </p><p>La <code class="literal">Session</code> se desconecta de cualquier conexión JDBC subyacente a la espera de una interacción del usuario. Este enfoque es el más eficiente en términos de acceso a la base de datos. La aplicación no necesita por sí misma tratar con el chequeo de versiones, ni re-unir instancias separadas, ni tiene que recargar instancias en cada transacción de la base de datos. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;earlier&nbsp;by&nbsp;the&nbsp;old&nbsp;session</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Obtain</span><span class="java_plain">&nbsp;a&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;JDBC&nbsp;connection</span><span class="java_separator">,</span><span class="java_plain">&nbsp;start&nbsp;transaction</span>
</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Only</span><span class="java_plain">&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;last&nbsp;transaction&nbsp;in&nbsp;conversation</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Also</span><span class="java_plain">&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;JDBC&nbsp;connection</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Only</span><span class="java_plain">&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;last&nbsp;transaction&nbsp;in&nbsp;conversation</span></pre><p>El objeto <code class="literal">foo</code> sabe en qué <code class="literal">Session</code> fue cargado. El dar inicio a una nueva base de datos en una sesión vieja obtiene una nueva conexión y reanuda la sesión. El guardar una transacción de la base de datos desconecta una sesión de la conexion JDBC y devuelve la conexión al pool. Después de la reconexión, para poder forzar una verificación de versión sobre datos que usted no está actalizando, puede llamar a <code class="literal">Session.lock()</code> con <code class="literal">LockMode.READ</code> en cualquier objeto que pueda haber sido actualizado por otra transacción. No necesita bloquear ningún dato que <span class="emphasis"><em>sí esté</em></span> actualizando. Usualmente configuraría <code class="literal">FlushMode.MANUAL</code> en una <code class="literal">Session</code> extendida, de manera que de hecho sólamente se permite persistir el último ciclo de transacción de la base de datos de todas las modificaciones realizadas en esta conversación. Sólamente esta última transacción de la base de datos incluiría la operación <code class="literal">flush()</code> y luego cierra -<code class="literal">close()</code>- la sesión para dar fin a la conversación. </p><p>Este patrón es problemático si la <code class="literal">Session</code> es demasiado grande para almacenarla durante el tiempo para pensar del usuario, por ejemplo, una <code class="literal">HttpSession</code> se debe mantener tan pequeña como sea posible. Como la <code class="literal">Session</code> también lo es el caché de primer nivel (obligatorio) y comprende todos los objetos cargados, probablemente podemos utilizar esta estrategia sólamente para unos pocos ciclos de pedido/respuesta. Debe utilizar una <code class="literal">Session</code> sólamente para una conversación única ya que pronto también tendrá  datos añejos. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>Las versiones anteriores de Hibernate necesitaban desconexión explícita y reconexión de una <code class="literal">Session</code>. Estos métodos ya no se aprueban ya que tienen el mismo efecto que dar inicio o finalizar a una transacción. </p></div><p>Mantenga la <code class="literal">Session</code> desconectada cerca a la capa de persistencia. Use un bean de sesión EJB con estado para mantener la <code class="literal">Session</code> en un entorno de tres capas . No la transfiera a la capa web ni la serialice en una capa separada para almacenarla en la <code class="literal">HttpSession</code>. </p><p>El patrón de sesión extendido, o <span class="emphasis"><em>sesión-por-conversación</em></span>, es más dificil de implementar con la administración de contexto de sesión actual. Necesita proporcionar su propia implementación de la <code class="literal">CurrentSessionContext</code> para esto, vea el Wiki de Hibernate para obtener más ejemplos. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-detached"/>13.3.3. Objetos separados y versionado automático</h3></div></div></div><p>Cada interacción con el almacenamiento persistente ocurre en una nueva <code class="literal">Session</code>. Sin embargo, las mismas instancias persistentes son reutilizadas para cada interacción con la base de datos. La aplicación manipula el estado de las instancias separadas cargadas originalmente en otra <code class="literal">Session</code> y luego las readjunta usando <code class="literal">Session.update()</code>, <code class="literal">Session.saveOrUpdate()</code>, o <code class="literal">Session.merge()</code>. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;</span><!-- <br/> --><span class="java_type">Session</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">saveOrUpdate</span><span class="java_separator">(</span><span class="java_plain">foo</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Use</span><span class="java_plain">&nbsp;merge</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;foo&quot;</span><span class="java_plain">&nbsp;might&nbsp;have&nbsp;been&nbsp;loaded&nbsp;already</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p>De nuevo, Hibernate chequeará las versiones de la instancia durante el vaciado, lanzando una excepción si tuvieron lugar conflictos en las actualizaciones. </p><p>También puede llamar a <code class="literal">lock()</code> en lugar de <code class="literal">update()</code> y utilizar <code class="literal">LockMode.READ</code> (realizando un chequeo de versión, evitando todos los cachés) si está seguro de que el objeto no ha sido modificado. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-customizing"/>13.3.4. Personalización del versionado automático</h3></div></div></div><p>Puede deshabilitar el incremento de la versión automática de Hibernate para ciertas propiedades y colecciones en particular estableciendo el atributo de mapeo <code class="literal">optimistic-lock</code> como <code class="literal">false</code>. Hibernate entonces ya no incrementará más las versiones si la propiedad se encuentra desactualizada. </p><p>Los esquemas heredados de la base de datos con frecuencia son estáticos y no pueden ser modificados. Inclusive otras aplicaciones podrían también acceder la misma base de datos y no saber cómo manejar los números de versión ni los sellos de fecha. En ambos casos, el versionado no puede confiarse a una 